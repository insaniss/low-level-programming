#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+LANGUAGE: ru
#+OPTIONS: ':t
#+OPTIONS: toc:1
#+OPTIONS: tasks:nil

#+TITLE: Семинар 4: Конечные автоматы


* Tема занятия
  :PROPERTIES:
  :UNNUMBERED: t
  :END:

  На этом занятии мы реализуем один из сложнейших кусочков первой лабораторной работы с помощью конечных автоматов, и это получится у нас легко и быстро.
  Мы потренируемся в их создании и кодировании, пронаблюдаем понятия полноты 


* Введение в конечные автоматы
  
  Конечный автомат (Finite State Machine) это:

  - Набор событий (/входные символы/).
  - Набор реакций (/выходные символы/).
  - Набор состояний, из них выбираем одно начальное, одно или более конечных.
  - Правила вида: "если мы в состоянии *A* и произошло событие *I*, демонстрировать реакцию *O* и перейти в состояние *B*".

    Общий вид правила:
  [[./img/fsm-io.svg]]


  - Реакцию можно не демонстрировать.
  - В какое состояние придём, такой и результат работы.

    Сначала посмотрим на автоматы без реакций, т.е. набор реакций пустой и все переходы помечены только входными символами.

** Пример. Чётное количество единиц  (5 минут)
   События: считывание очередного символа из строчки.

   [[./img/fsm-2.svg]]


   Автомат можно мысленно запустить и дать ему на вход последовательность событий.
   Затем, стартовав из начального состояния, пройтись по цепочке переходов (одно
   событие --- один переход).

   *Вопрос* по какой цепочке переходов пройдёт этот автомат на входной строке 01001? Считаем, что никаких реакций нет.

** Пример. Разбираем число со знаком (5 минут)

   [[./img/fsm-1.svg]]

   *Вопрос* а если число без знака? Нарисуйте автомат для распознавания таких чисел.

** Пример. Пять состояний процесса (5 минут)
   
   [[./img/fsm-processes.svg]]

   *Вопрос* Расскажите, о чём эта диаграмма? Верна ли она для всех операционных систем?

** Другие use-cases

   - Управление роботами, машинами.
     - События = показания сенсоров.
     - Реакции = действия.
   - Сетевые протоколы.
     - События = приём пакетов разного типа.
     - Реакции = ответы.

* Чем автоматы непривычны

  - Состояние компьютера --- значения всех регистров и ячеек памяти.
  - Состояние автомата  --- "кружочек", одно из фиксированного набора.
  - У автомата нет памяти, никакой.

  Когда в алгоритме действия и условия глобальны, автоматы удобны для его описания.

* Как закодировать автомат на ассемблере (15 минут)

  Прочитайте на страницах 103--105 книги "Low-level programming" о том, как закодировать на ассемблере конечный автомат.

  *Вопрос* Закодируйте автомат, проверяющий, является ли строчка числом (т.е. что она удовлетворяет регулярному выражению =\s*[0-9]+\s*=  ).

* Автоматы и регулярные выражения (15 минут)
  
  Прочитайте на страницах 106--108 книги "Low-level programming" о  связи регулярных выражений и конечных автоматов.


  *Вопрос* Нарисуйте автомат, соответствующий регулярному выражению =[+-]?[0-9]+=.



  На автоматах легко продемонстрировать понятия /недетерминизма/, /неопределённости/ и /полноты/.

* Что такое недетерминизм?

  Поведение --- последовательность переходов по состояниям.

  - Несколько возможных переходов по одинаковому событию.
    - Мы в состоянии *A*, что если на входе 3?
  - Не одно поведение, а *множество равноправных*.

  [[./img/fsm-nondeterm.svg]]



  *Связано с*: неопределённым порядком вычислений в C, слабой моделью памяти.

** Недетерминизм в C

   #+BEGIN_SRC c
     int f() { print("f"); return 1; }
     int g() { print("g"); return 1; }

     ...
     f() + g();
   #+END_SRC

   [[./img/fsm-nondeterm-c.svg]]


   =f() + g();= - =1 + g();= - =1 + 1= - =2= 

   =f() + g();= - =f() + 1;= - =1 + 1= - =2= 


* Что такое неопределённость?

  - Мы в состоянии *A*, что будет если на вход придёт 1?
  - Нет поведения.

  [[./img/fsm-nondeterm.svg]]

  При реализации системы в неописанных случаях поведение &laquo;как получится&raquo;.

  *Связано с*: неопределённым поведением в C; используется чтобы
  компилятор вставлял меньше проверок.

  ---

* Что такое полнота?

  - Полный автомат = не может быть неопределённого поведения.
  - Из каждого состояния для каждого возможного события есть переход.
  - Неполный можно достроить до полного добавив состояние.

Пример неполного автомата:

   [[./img/fsm-1.svg]]

Достроим его до полного:

   [[./img/fsm-3.svg]]

*Кодировать на ассемблере имеет смысл только полные автоматы*.

Автоматы легко анализировать, на их основе легко писать программы, и их можно полностью проанализировать, в отличие от программ на привычных языках программирования (см. материалы второй лекции).

* Разбор чисел (30 минут)

  Задача, которая ставится в функции =read_uint= из первой лабораторной работы, немного сложнее, чем просто ответить на вопрос "да" или "нет" (прийти в одно из конечных состояний).
  Нужно также подсчитать число, взяв его десятичные цифры из строки.

  Важно, что все действия глобальны (с регистрами) и происходят в момент переходов. Поэтому мы можем воспринимать их как "реакции" системы на входные символы (буквы/символы из входной строки). 

  *Вопрос* Нарисуйте автомат для функции =read_uint= на основе заготовки из одного из предыдущих пунктов; снабдите его переходы также действиями над регистрами, в результате которых в =rax= окажется разобранное из строчки число, а в =rdx= количество символов в нём. Затем закодируйте этот автомат на ассемблере и проверьте с помощью теста для первой лабораторной работы.
  
  *Вопрос* внимательно посмотрите на все функции, которые необходимо реализовать в первой лабораторной. Для каких из них удобно сначала нарисовать автомат, а затем закодировать его на ассемблере?
  
