#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+LANG: ru
#+INCLUDE: "../common/org-header.org"
#+TITLE: Семинар 11: Синтаксис языка

* Аспекты языка (20 минут)

  В каждом языке программирования есть три аспекта: синтаксис, семантика и прагматика.

** Синтаксис

   Синтаксис определяет, какие программы на этом языке считаются "правильно сформированными".

    Примеры синтаксически-неправильных программ:
#+begin_src c
int x = "hello" ; // несоответствие типов 

int x = y + 23 ; // если переменная y не объявлена

int int = 4;   // после int ожидается имя переменной,
// не может совпадать с ключевым словом int
#+end_src


** Семантика

   Семантика определяет значение конструкций языка.
   Описывать её можно на естественном языке (например, в стандарте языка C она описана на английском) или на языке формальной логики.
   Семантика наделяет каждую конструкцию каким-то поведением в зависимости от контекста, например, сопоставляет операции "*" смысл "умножить левую часть на правую, если звёздочка между двумя выражениями", или смысл "слева от звёздочки --- тип-указатель" в другом контексте.
   
   Бывает, что у какой-то конструкции нет смысла, хотя программа и синтаксически-корректна.
   Нет смысла значит что стандарт языка или явно отказался от того, чтобы определять, что же произойдёт, или просто обошёл этот момент стороной, и теперь нам непонятно.
  Такая ситуация называется /неопределённым поведением/.
 
  Примеры программ, в которых нет семантики:

#+begin_src c
int y = 0;
int x = 1 / y; // деление на ноль

int z = * (NULL); // обращение по указателю NULL неопределено.


int k = x++ + ++x; // неизвестно, какая операция выполнится раньше:
// x++ или ++x, отсюда и результат может быть разный.

#+end_src

** Прагматика

   Прагматика в языках программирования --- то, как меняется семантика при трансляции в целевую архитектуру.
   Например, в программе на C есть неопределённое поведение, а в программе на ассемблере --- нет.
   Значит, после трансляции неопределённое поведение доопределится --- а как?
   Некоторые дополнительные директивы для компилятора и конструкции языка нужны, чтобы учитывать особенности вычислительной машины, реализации, для повышения эффективности

   Примеры прагматических аспектов:

   - Выравнивание в памяти
   - Упаковка полей структур (как поля расположены в памяти, есть ли между ними отступы?)
   - Выбор способа трансляции формул с плавающей точкой.
     
Например, при компиляции =gcc= может принимать опцию =-ffast-math=, которая:

- Выключает строгую совместимость со стандартом IEEE
- Сокращает количество записей в переменную =errno=.
- Вносит предположение что в формулах не встречается NaN, ноль или бесконечность.
- и включает ещё некоторые оптимизации.
    
*Вопрос* скомпилируйте следующий файл и посмотрите содержимое секции =.data= с помощью =objdump=. По какому адресу начинается переменная =x=? Попробуйте убрать =_Alignas(128)= и объясните эффект. 


    
* Синтаксис (50 минут)

  Мы привыкли смотреть на программы как на текст.
  Однако текстовое представление имеет ряд недостатков.

  Прежде всего, текст может неоднозначно трактоваться.

  Как думаете, что выведет эта программа если =x = -4=?

  #+begin_src c
if (x > 0)
  if (y > 0) {
    print("yes");
  }
  else {
    print("no");
  }
#+end_src


А если посмотреть на неё так?


  #+begin_src c
if (x > 0)
  if (y > 0) {
    print("yes");
  }
else {
  print("no");
}
#+end_src


*Вопрос* напишите минимальный пример с таким кодом, скомпилируйте его со строгим соответствием стандарту C17 (=-std=c17 -pedantic -Wall=).  Что выведет компилятор? Объясните сообщение.


Как мы видим из этого примера, в плохо спроектированных языках текстовое представление бывает неоднозначным.

Более того, многие элементы программы не несут никакой операционной нагрузки (комментарии, ключевые слова).
Некоторые очевидно одинаковые программы представляются разным текстом:

#+begin_src c
int x = a * b + c;
int x = (a * b) + c;
int x = ((a * b) + c);
int x = (((a * b) + c));
// скобки нужны только чтобы правильно разобрать выражение
// но здесь они избыточны
// этот комментарий тоже ни на что не влияет,
// хотя в тексте программы присутствует.
#+end_src


О программе удобнее думать не как о её текстовом представлении.
Текст это лишь проекция её структуры на экран; на самом деле лучшее представление о её структуре даёт так называемое /дерево абстрактного синтаксиса/, abstract syntax tree, AST.
  
  В нём каждой конструкции языка сопоставляется тип вершин дерева, например:

#+begin_src c
y*z
#+end_src

# [
#+INCLUDE: "../common/before-image.org"
#+attr_latex: :width 0.30\textwidth
#+attr_html: :width 30%
{{{if-latex-else([[./img/ast0.svg]],)}}}
#+INCLUDE: "../common/after-image.org"
# ]


# <
#+BEGIN_EXPORT md
<p align='center'> <img width='30%'  src='./img/ast0.svg' /> </p>
#+END_EXPORT
# >

#+begin_src c
x+y*z
#+end_src


#+INCLUDE: "../common/before-image.org"
#+attr_latex: :width 0.3\textwidth
#+attr_html: :width 30%
{{{if-latex-else([[./img/ast1.svg]],)}}}
#+INCLUDE: "../common/after-image.org"

#+BEGIN_EXPORT md
<p align='center'> <img width='30%'  src='./img/ast1.svg' /> </p>
#+END_EXPORT

#+begin_src c
if (x+y*z) {
  print("yes");
  }
else {
  print("no");
  }
#+end_src


# [
#+INCLUDE: "../common/before-image.org"
#+attr_latex: :width 0.6\textwidth
#+attr_html: :width 60%
{{{if-latex-else([[./img/ast2.svg]],)}}}
#+INCLUDE: "../common/after-image.org"
# ]


# <
#+BEGIN_EXPORT md
<p align='center'> <img width='30%'  src='./img/ast2.svg' /> </p>
#+END_EXPORT
# >

Смысл такого представления программы в том, что оно чётко и недвусмысленно определяет её структуру и не зависит от форматирования (пробелы, переносы строк и т.д.).
Кроме того, оно не зависит и от точных названий ключевых слов.
Действительно, станет ли язык C другим, если всё, что мы поменяем --- заменим ключевое слово =while= на =whiiile= с тем же смыслом?


На таком древовидном представлении программы легче говорить про её семантику.
Значение языковых конструкций задаётся именно для вершин AST.
Где это встречается:

- При разработке компиляторов или интерпретаторов практически первое, что происходит с программой --- её преобразование в AST.
Также этим занимаются IDE и текстовые редакторы.
- Форматы хранения данных типа JSON тоже представимы как AST.
- Разметки текста (Markdown, Org...)
- Вообще любые структурированные текстовые форматы (файлы конфигураций и т.д.)
- В документах описывающих языки программирования (стандарты языков).

Например, вот описание конструкции =_Alignas= из стандарта C. Как видите, в нём используется =type-name= и =constant-expression= --- типы узлов AST-дерева кода (немного упрощая).


#+DOWNLOADED: screenshot @ 2021-11-16 00:32:30
[[file:Синтаксис/2021-11-16_00-32-30_screenshot.png]]


- Знание AST бывает полезным при попытке понять сообщения об ошибках, выдающиеся компилятором (см. первое задание :)


Теперь изучим AST простой программы на Java с помощью 

https://astexplorer.net/

#+begin_src java
public class Program {
    public static void main(String[] args) {
        int x = 100;
        if (x > 0) {
            System.out.println("Greater than zero"); 
        }
        else {
            System.out.println("Less than or equal to zero"); 
        }
    }
}
#+end_src


*Вопрос* найдите в AST для примера выше имя класса. Какие поля хранятся в узле этого дерева? Как вы думаете, зачем?

*Вопрос* найдите в AST для примера выше конструкцию if. Добавьте код так, чтобы повторить ситуацию с вложенным в if предложением if-else из первого примера. Нарисуйте примерный вид AST для него.



Теперь изучим простой принтер для AST-дерева. Дерево будем задавать прямо в коде с помощью небольшого доменно-специфичного языка, который определим прямо в программе.

*Вопрос* изучите файл =printer0.c=.

#+include: "printer0.c" src c

Допишите в =main= код, чтобы вывести следующие выражения (можно со скобками):

- 999 + 728
- 4+2*9

Расширьте этот пример, добавив тип вершин AST для деления и принтер для него.
Выведите следующее выражение:

- (3+5) * (9 / 7)


  

     
