#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+LANGUAGE: ru
#+OPTIONS: ':t
#+OPTIONS: toc:1
#+OPTIONS: tasks:nil
#+TITLE: Семинар 2:  основы языка ассемблера
 -----



* Tема занятия
  :PROPERTIES:
  :UNNUMBERED: t
  :END:

  На этом занятии мы начнём разбирать ассемблерные программы.
  
   - Разбор =Hello, world!=
   - Системные вызовы.
   - Секции
   - Важные регистры общего назначения.
   - Служебные регистры =rip=, =rsp=
   - Отладка. Настройка =gdb= для синтаксиса Intel. Файл =.gdbrc=.
   - Изучение памяти в отладчике.
   - Шаги вперёд и назад в отладчике.

* Hello, world!

  Напомним программу из прошлого занятия.

  #+BEGIN_SRC asm
      ; hello.asm 
        section .data
        message: db  'hello, world!', 10

        section .text
        global _start

        _start:
            mov     rax, 1           ; 'write' syscall number
            mov     rdi, 1           ; stdout descriptor
            mov     rsi, message     ; string address
            mov     rdx, 14          ; string length in bytes
            syscall

        mov     rax, 60          ; 'exit' syscall number
            xor     rdi, rdi
            syscall
  #+END_SRC


Чтобы программировать на ассемблере вам не нужно знать всё многообразие команд для AMD64. 
Для большинства сценариев достаточно знать ~30 инструкций, причём многие из них очень похожи.

Например:

- =jz= :: перейти на адрес если установлен флаг ZF (Zero flag)
- =js= :: перейти на адрес если установлен флаг SF (Sign flag)

... и так для каждого флага.
  
** Вопросы (25)
  :PROPERTIES:
  :UNNUMBERED: t
  :END:

  - Прочитайте страницы 17--21 из книги "Low-level programming" чтобы понять, как выполняется программа.

  - Что такое секция? Зачем они нужны?
  - Что такое метка (label)?
  - Что означает инструкция =xor r, r=, где =r= --- любой регистр?
  - Найдите страницу, соответствующую инструкции =mov= в Intel Sofware Developer Manual и просмотрите её.
    
      Пожалуйста, не используйте Google чтобы искать справки по командам --- используйте [Intel® 64 and IA-32 Architectures Software Developer’s Manuals](https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html). Информация в интернете часто неактуальна и относится только к устаревшим моделям процессоров. 
       В части мануала под названием Instruction Reference есть странички для каждой инструкции.
 
  
* GDB (45)

=gdb= это мощный отладчик, который можно использовать для изучения функционирования программы. Он позволяет выполнять программы по шагам и изучать её состояние, включая слепок памяти и регистров. Чтобы отлаживать программу зачастую мы исполяем её по шагам и следим за состоянием. Мы также можем исполнять её пока некоторое условие не станет истинным или до определённого места в коде. Такое место называется /breakpoint/, или /точка останова/.

У =gdb= есть собственная система команд, управляющая программой, которую вы изучаете. Поэтому когда вы запускаете =gdb= вы видите его приглашение командной строки, куда вы и вводите команды. Отличие работы с =gdb= через его систему команд, а не графический интерфейс с кнопками, в том, что текстовые команды можно комбинировать в скрипты, автоматизирующие работу с отлаживаемой программой.

** Запуск программы в =gdb=

Есть два основных способа использовать =gdb= с программой: с помощью его
собственной команды =file=, или запустив с путём к программе в качестве
аргумента.

#+BEGIN_SRC
(gdb) file hello
Reading symbols from hello ...(no debugging symbols found)...done.
#+END_SRC

** Основные команды

*С помощью клавиши =<tab>= вы можете вызывать автодополнение.*

Две самые важные команды:

- =quit= выход
- =help cmd= справка по команде =cmd=

** Файл =.gdbinit=

Команды из файла =~/.gdbinit= выполняются при старте =gdb=. 
Добавьте туда строчку:

#+BEGIN_SRC
set auto-load safe-path /
#+END_SRC

Тогда вы сможете создавать файл =.gdbinit= и в директории с файлом, который вы
отлаживаете.


** Переключение на Intel синтаксис

По умолчанию =gdb= для ассемблера использует AT&T синтаксис. Чтобы перманентно переключиться на Intel-синтаксис добавьте в =.gdbinit=:

#+BEGIN_SRC
set disassembly-flavor intel
#+END_SRC

** Команды управления программой

Ещё некоторые полезные команды =gdb= (текст в =<угловых скобках>= заменяется на аргументы):

- =run= запускает выполнение программы;
- =break <метка>= ставит точку останова на метку. Во время работы программы с подключенным отладчиком она будет останавливаться как только доходит до такой точки;
- =break *<адрес>= ставит точку останова на определённый адрес;
- =continue= продолжает выполнение программы;
- =stepi= (сокращённо =si=) выполняет ровно одну инструкцию;
- =nexti= (сокращённо =ni=) выполняет ровно одну инструкцию, но не заходит в функции, вызванные с помощью инструкции ассемблера =call=. Будет выполнена вся функция и программа остановится на следующей в коде после =call= инструкции.
- =layout= переключается между режимами интерфейса, см. далее.

** Запуск и исследование программы

 Загрузим Hello, world! в отладчик, установим брейкпоинт на метку =_start=, с которой начинается выполнение любой ассемблерной программы, и запустим её.

 [[./img/gdb-1.png
 ]]

 Чтобы нам было удобнее наблюдать состояние программы, мы включим режим псевдографики.


 #+BEGIN_SRC
 layout asm
 layout regs
 #+END_SRC

 В этом режиме есть три окна:

 - Вверху видны названия регистров и их текущие значения;
 - В средней части виден результат дизассемблирования программы;
 - Внизу вы по прежнему можете вводить команды.


 [[./img/gdb-2.png]]

 В фокусе находится только одно из этих окон; с помощью =Ctrl-X= и =o= вы
 можете менять фокус и затем взаимодействовать с другими окнами.
 Стрелками можно скроллить окно, на котором установлен фокус.


*Задание* с помощью =gdb= запустите программу Hello, world!. Выполните её по шагам. В чём разница между =nexti=, =stepi=? Что такое step over?

*** Состояние программы

В следующих двух командах используется обозначение =/FMT= для указания формата данных.

- =print /FMT <val>= позволяет посмотреть содержимое регистров или памяти. Регистры предваряются долларом, например, =print /x $rax=.
- =x /FMT <address>= позволяет смотреть содержимое памяти. Он отличается от =print= тем, что принимает адрес, т.е. имеет один уровень косвенности.

     =/FMT= позволяет нам явно указывать тип данных, который мы изучаем. В зависимости от него меняются две вещи:
     
     - формат отображения (например, основание системы счисления);
     - ожидаемый размер. 

      Например, в памяти лежит двоичное число =0xff78=. Если мы считаем 1 байт равный =0x78=, то это число мы интерпретируем как положительное; если же мы считаем 2 байта, то оно может быть интерпретировано как отрицательное (почему?)


      Самые полезные форматы:
      
      * =x= (hexadecimal) 
      * =a= (address)
      * =i= (instruction, =gdb= попытается дизассемблировать инструкцию начиная с данного адреса)
      * =c= (char)
      * =s= (null-terminated string) -- строка, в которой каждый байт соответствует
        коду символа по таблице ASCII, а конец строки обозначен символом с кодом
        =0x00=.
      
      Самые полезные размеры: =b= (байт) =g= (giant, 8 байт).


*Задание* с помощью =gdb= запустите программу Hello, world! Проследите за изменениями регистров =rip= на протяжении работы программы. Что оно означает? Также обратите внимание на значение =rax= после системного вызова =write=.

** Примеры команд


 * Посмотреть содержимое =rax=:

#+BEGIN_SRC
(gdb) print $rax
$1 = 1234605616436508552
#+END_SRC

 * Посмотреть первый символ строчки которая находится на метке =msg=:

#+BEGIN_SRC
(gdb) print /c message
$2 = '0'
#+END_SRC


 * Дизассемблирование инструкции по адресу =_start= (тут используется оператор =&= для взятия адреса метки):

#+BEGIN_SRC
(gdb) x /i &_start
   0x4000b0 <_start>:   movabs rax,0x1122334455667788
#+END_SRC

 * Дизассемблирование следующей инструкции:

#+BEGIN_SRC
(gdb) x /i $rip
=> 0x4000e9 <_start.loop+32>:   jne    0x4000c9 <_start.loop>
#+END_SRC

 * Чему равны 12 первых символов начиная с метки =message=?

#+BEGIN_SRC
(gdb) x /5cb &message
0x402000 <message>:     104 'h' 101 'e' 108 'l' 108 'l' 111 'o'
#+END_SRC

Формат может начинаться с указания количества элементов. Поэтому =/12cb= означает "12 элементов-символов, каждый по 1 байту".


  * Посмотреть последние 8 байт в стеке:

#+BEGIN_SRC
(gdb) x /xg $rsp
0x7fffffffdf90: 0x0000000000000001
#+END_SRC


 * Посмотреть второй элемент размера =qword= (8 байт) в стеке:
    
#+BEGIN_SRC
(gdb) x /xg $rsp
(gdb) x/xg $rsp+8
0x7fffffffd168:	0x00007fffffffd513
#+END_SRC

*Вопрос* прочитайте =help x=.

Чтобы использовать =gdb= эффективно, не забывайте про ключ компиляции =-g= (зачем?).

Кроме того, =gdb= позволяет перемещаться и изучать стек вызовов, вычислять арифметические выражения, запускать функции, автоматизировать отладку с помощью скриптов на Python и многое другое. 


*Задание* используйте [[https://sourceware.org/gdb/onlinedocs/gdb/Reverse-Execution.html][эту страницу]] и попробуйте при отладке программы пройти назад, а не вперед.

Если вам интересно узнать больше о возможностях GDB, советуем взглянуть на ресурс [[Debugging with gdb][http://sourceware.org/gdb/current/onlinedocs/gdb/]].

